---
data:
  _extendedDependsOn: []
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: true
  _pathExtension: cpp
  _verificationStatusIcon: ':x:'
  attributes: {}
  bundledCode: "Traceback (most recent call last):\n  File \"/opt/hostedtoolcache/Python/3.11.2/x64/lib/python3.11/site-packages/onlinejudge_verify/documentation/build.py\"\
    , line 71, in _render_source_code_stat\n    bundled_code = language.bundle(stat.path,\
    \ basedir=basedir, options={'include_paths': [basedir]}).decode()\n          \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \  File \"/opt/hostedtoolcache/Python/3.11.2/x64/lib/python3.11/site-packages/onlinejudge_verify/languages/cplusplus.py\"\
    , line 187, in bundle\n    bundler.update(path)\n  File \"/opt/hostedtoolcache/Python/3.11.2/x64/lib/python3.11/site-packages/onlinejudge_verify/languages/cplusplus_bundle.py\"\
    , line 401, in update\n    self.update(self._resolve(pathlib.Path(included), included_from=path))\n\
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \
    \ File \"/opt/hostedtoolcache/Python/3.11.2/x64/lib/python3.11/site-packages/onlinejudge_verify/languages/cplusplus_bundle.py\"\
    , line 260, in _resolve\n    raise BundleErrorAt(path, -1, \"no such header\"\
    )\nonlinejudge_verify.languages.cplusplus_bundle.BundleErrorAt: graph/rerooting_dp.hpp:\
    \ line -1: no such header\n"
  code: "#define PROBLEM \"https://judge.yosupo.jp/problem/aplusb\"\n#include \"my_template.hpp\"\
    \n#include \"other/io.hpp\"\n\n#include \"graph/base.hpp\"\n#include \"graph/tree.hpp\"\
    \n#include \"graph/rerooting_dp.hpp\"\n\n#include \"linalg/xor/vector_space.hpp\"\
    \n#include \"linalg/xor/mat_inv.hpp\"\n#include \"linalg/xor/transpose.hpp\"\n\
    \nconst int LOG = 64;\n\nvc<u64> solve_QOJ_5445(int N, vc<int> par, vvc<u64> dat)\
    \ {\n  using SP = Vector_Space<u64>;\n\n  Graph<bool, 0> G(N);\n  FOR(v, 1, N)\
    \ { G.add(par[v - 1] - 1, v); }\n  G.build();\n  Tree<decltype(G)> tree(G);\n\n\
    \  vc<SP> dual(N);\n  FOR(v, N) {\n    SP x;\n    for (auto&& e: dat[v]) x.add_element(e);\n\
    \    dual[v] = x.orthogonal_space(LOG);\n  }\n\n  /*\n  \u6728 dp \u306E\u72B6\
    \u614B\n  \u30FB\u6DF1\u3055 d \u306E\u3068\u304D\u306B dual space \u306B a \u304C\
    \u8FFD\u52A0\u3055\u308C\u308B (d,a) \u3068\u3044\u3046\u30A4\u30D9\u30F3\u30C8\
    \u306E\u5217\n  \u30FB\u9AD8\u3005 64\n  */\n  using P = pair<int, u64>;\n  using\
    \ Data = vc<P>;\n  Data unit = {};\n\n  auto fee = [&](Data& x, Data& y) -> Data\
    \ {\n    // merge sort\n    Data z;\n    auto V = SP{};\n    auto add = [&](P&\
    \ dat) -> void {\n      if (len(V) == LOG) return;\n      if (V.add_element(dat.se))\
    \ z.eb(dat.fi, V.dat.back());\n    };\n\n    int p = 0, q = 0;\n    while (p <\
    \ len(x) || q < len(y)) {\n      if (len(V) == LOG) break;\n      if (p == len(x))\
    \ { add(y[q++]); }\n      elif (q == len(y)) { add(x[p++]); }\n      else {\n\
    \        if (x[p].fi < y[q].fi) {\n          add(x[p++]);\n        } else {\n\
    \          add(y[q++]);\n        }\n      }\n    }\n    return z;\n  };\n  auto\
    \ fev = [&](Data& x, int v) -> Data {\n    Data y;\n    for (auto&& a: dual[v].dat)\
    \ y.eb(0, a);\n    auto V = dual[v];\n    for (auto&& [d, a]: x) {\n      if (len(V)\
    \ == LOG) break;\n      if (V.add_element(a)) y.eb(d, V.dat.back());\n    }\n\
    \    return y;\n  };\n  // e \u306F v \u304B\u3089\u51FA\u308B\u6709\u5411\u8FBA\
    \n  auto fve = [&](Data x, auto& e) -> Data {\n    for (auto&& [d, a]: x) ++d;\n\
    \    return x;\n  };\n  Rerooting_dp<decltype(tree), Data> dp(tree, fee, fev,\
    \ fve, unit);\n\n  vc<u64> ANS(N);\n  FOR(v, N) {\n    auto event = dp[v];\n \
    \   // full space \u306B\u3057\u3066\u304A\u304F\n    vc<int> done(LOG);\n   \
    \ for (auto&& [d, a]: event) done[topbit(a)] = 1;\n    FOR(i, LOG) if (!done[i])\
    \ event.eb(N, u64(1) << i);\n    assert(len(event) == LOG);\n    vc<u64> mat(LOG);\n\
    \    FOR(i, LOG) mat[i] = event[i].se;\n    mat = mat_inv<u64>(mat);\n    mat\
    \ = transpose<u64>(LOG, LOG, mat);\n    FOR(j, LOG) { event[j].se = mat[j]; }\n\
    \    event.insert(event.begin(), {0, u64(0)});\n\n    SP X{};\n    FOR_R(i, 1,\
    \ 1 + LOG) {\n      u64 x = event[i].se;\n      X.add_element(x);\n      int t1\
    \ = event[i - 1].fi, t2 = event[i].fi;\n      if (t1 < t2) {\n        u64 ans\
    \ = X.get_max(0);\n        ANS[v] += ans * u64(t2 - t1);\n      }\n    }\n  }\n\
    \  return ANS;\n}\n\nvoid test_QOJ_5445() {\n  int N = 5;\n  vc<int> par = {1,\
    \ 2, 2, 3};\n  vvc<u64> dat(N);\n  dat[0] = {83, 75, 58};\n  dat[1] = {125, 124,\
    \ 58, 16};\n  dat[2] = {39, 125, 71, 112};\n  dat[3] = {69, 66, 5};\n  dat[4]\
    \ = {48, 73, 69, 6};\n  auto ANS = solve_QOJ_5445(N, par, dat);\n  assert(ANS\
    \ == vc<u64>({171, 125, 183, 142, 243}));\n}\n\nvoid solve() {\n  LL(a, b);\n\
    \  print(a + b);\n}\n\nsigned main() {\n  test_QOJ_5445();\n  solve();\n  return\
    \ 0;\n}"
  dependsOn: []
  isVerificationFile: true
  path: test/mytest/QOJ5445.test.cpp
  requiredBy: []
  timestamp: '1970-01-01 00:00:00+00:00'
  verificationStatus: TEST_WRONG_ANSWER
  verifiedWith: []
documentation_of: test/mytest/QOJ5445.test.cpp
layout: document
redirect_from:
- /verify/test/mytest/QOJ5445.test.cpp
- /verify/test/mytest/QOJ5445.test.cpp.html
title: test/mytest/QOJ5445.test.cpp
---
